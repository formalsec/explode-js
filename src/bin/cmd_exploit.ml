open Explode_js

let run_with_timeout limit f =
  let exception Sigchld in
  let open Unix in
  let did_timeout = ref false in
  let pid = fork () in
  if pid = 0 then begin
    exit (f ())
  end
  else begin
    ( try
        Sys.set_signal Sys.sigchld (Signal_handle (fun _ -> raise Sigchld));
        Unix.sleepf limit;
        did_timeout := true;
        Unix.kill pid Sys.sigkill;
        Sys.set_signal Sys.sigchld Signal_default
      with Sigchld -> () );
    let chldpid, status = waitpid [] pid in
    assert (chldpid = pid);
    if !did_timeout then `Timeout
    else
      match status with
      | WEXITED n -> `Ok n
      | WSIGNALED _ | WSTOPPED _ -> `Timeout
  end

let run ~lazy_values ~input_file ~workspace_dir ~time_limit:_ =
  let open Result in
  let* _ = Bos.OS.Dir.create workspace_dir in
  let workspace_dir = Fpath.(workspace_dir // rem_ext (base input_file)) in
  let* sym_result = Sym_exec.run_file ~lazy_values ~workspace_dir input_file in
  let+ () = Replay.run_single ~workspace_dir input_file sym_result in
  0
