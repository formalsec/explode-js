module type S = sig
  val default : Template.t

  val prototype_pollution : Template.t

  val dispatch : Scheme.t -> Template.t
end

let dispatch ?(needs_client = false) default prototype_pollution path_traversal
    = function
  | Some (Vuln_type.Cmd_injection | Code_injection) -> default
  | Some Path_traversal when needs_client -> path_traversal
  | Some Path_traversal -> default
  | Some Proto_pollution | None -> prototype_pollution

module Literal = struct
  open Scheme

  let default =
    Template.(text "// Vuln: " & var "vuln_ty" & text "\n" & var "test" & eof)

  let path_traversal =
    Template.(
      text "// Vuln: " & var "vuln_ty" & text "\n\n"
      & text "const net = require('net');\nvar url =\""
      & var "request_url" & text "\";\nvar port =\"" & var "port"
      & text "\";\n\n"
      & text
          "const request = [\n\
          \  `GET /${url} HTTP/1.1`,\n\
          \  `Host: localhost:${port}`,\n\
          \  `User-Agent: exploit-script`,\n\
          \  `Connection: close`,\n\
          \  ``,\n\
          \  ``\n\
           ].join('\\r\\n');\n\n\
           const client = net.createConnection({ host: 'localhost', port: port \
           }, () => {\n\
          \  client.write(request);\n\
           });\n\n\
           client.on('data', (data) => {\n\
          \  console.log(data.toString());\n\
           });\n\n\
           client.on('end', () => {\n\
          \  console.log('Disconnected from server');\n\
           });\n"
      & eof )

  let prototype_pollution =
    Template.(
      text "// Vuln: " & var "vuln_ty" & text "\n" & var "test" & text "\n"
      & text "if (({}).polluted == \"yes\") { throw Error(\"I pollute.\"); }\n"
      & text
          "if (({}).toString == \"polluted\") { throw Error(\"I pollute.\"); }"
      & eof )

  let dispatch ?needs_client =
    dispatch ?needs_client default prototype_pollution path_traversal

  let fresh_str =
    let id = ref 0 in
    fun () ->
      incr id;
      Fmt.str "x_%d" !id

  let array_iter x f arr = List.iteri (fun i v -> f (Fmt.str "%s%d" x i, v)) arr

  let pp_array (iter : ('a -> unit) -> 'b -> unit) pp_v fmt v =
    Fmt.iter ~sep:(fun fmt () -> Fmt.string fmt ", ") iter pp_v fmt v

  let rec pp_param model (box : ('a, Format.formatter, unit) format) fmt
    ((x, ty) : string * param_type) =
    let rec pp_p fmt (x, ty) =
      match ty with
      | Any | Number | String | Boolean ->
        let v = Model.get model x in
        Fmt.pf fmt "%a" Value.pp v
      | Function -> Fmt.pf fmt {|(_) => { return () => {}; };|}
      | Object `Lazy -> Fmt.pf fmt "{}"
      | Object (`Polluted 1) ->
        Fmt.pf fmt {|{ ["__proto__"]: { "polluted": "yes" } }|}
      | Object (`Polluted 2) ->
        Fmt.pf fmt {|{ ["__proto__"]: { "toString": "polluted" } }|}
      | Object (`Polluted 3) ->
        Fmt.pf fmt {|{ "constructor": { "prototype": { "polluted": "yes" } } }|}
      | Object (`Normal props) ->
        Fmt.pf fmt "@[{ %a@ }@]" (pp_obj_props model) props
      | Array arr -> Fmt.pf fmt "[ %a ]" (pp_array (array_iter x) pp_p) arr
      | Union _ | Object (`Polluted _) -> assert false
    in
    Fmt.pf fmt box x pp_p (x, ty)

  and pp_obj_props map fmt props =
    Fmt.list
      ~sep:(fun fmt () -> Fmt.pf fmt "@\n, ")
      (pp_param map "@[<hov 2>%s:@ %a@]")
      fmt props

  and pp_params_as_decl map fmt (params : (string * param_type) list) =
    Fmt.list
      ~sep:(fun fmt () -> Fmt.pf fmt ";@\n")
      (pp_param map "@[<hov 2>var %s =@ %a@]")
      fmt params

  let pp_params_as_args fmt (args : (string * 'a) list) =
    let args = List.map fst args in
    let sep fmt () = Fmt.pf fmt ", " in
    Fmt.list ~sep Fmt.string fmt args

  let normalize =
    String.map (fun c ->
      match c with
      | '.' | ' ' -> '_'
      | _ -> c )

  let rec pp assignments fmt { source; params; cont; _ } =
    let open Option in
    if List.length params > 0 then
      Fmt.pf fmt "%a;@\n" (pp_params_as_decl assignments) params;
    match (cont, source) with
    | None, Some source -> Fmt.pf fmt "%s(%a);" source pp_params_as_args params
    | Some (Return ret), Some source ->
      let var_aux = Fmt.str "ret_%s" (normalize source) in
      Fmt.pf fmt "var %s = %s(%a);@\n" var_aux source pp_params_as_args params;
      let source =
        let* ret_source = ret.source in
        Some (String.cat var_aux ret_source)
      in
      pp assignments fmt { ret with source }
    | Some (Sequence cont), Some source ->
      Fmt.pf fmt "%s(%a);@\n" source pp_params_as_args params;
      pp assignments fmt cont
    | (Some (Client _ | Return _ | Sequence _) | None), _ -> assert false

  let to_string map v = Fmt.str "%a" (pp map) v

  let render map ({ Scheme.ty; _ } as scheme) =
    let template, models =
      match Scheme.client scheme with
      | `None ->
        ( dispatch ty
        , [ ("vuln_ty", Fmt.str "%a" (Fmt.option Vuln_type.pp) ty)
          ; ("test", to_string map scheme)
          ] )
      | `Client (_request_ty, port) ->
        let request_url =
          match Model.Map.find_opt "request.url" map with
          | None -> "./exploited"
          | Some (String s) -> s
          | Some _ -> assert false
        in
        ( dispatch ~needs_client:true ty
        , [ ("vuln_ty", Fmt.str "%a" (Fmt.option Vuln_type.pp) ty)
          ; ("request_url", request_url)
          ; ("port", Int.to_string port)
          ] )
    in
    Template.render template models
end

module Symbolic = struct
  open Scheme

  let default =
    Template.(
      text "var esl_symbolic = require(\"esl_symbolic\");\n" & Literal.default )

  let prototype_pollution =
    Template.(
      text "var esl_symbolic = require(\"esl_symbolic\");\n"
      & Literal.prototype_pollution )

  let dispatch = dispatch default prototype_pollution default

  let fresh_str =
    let id = ref 0 in
    fun () ->
      incr id;
      Fmt.str "x_%d" !id

  let array_iter x f arr = List.iteri (fun i v -> f (Fmt.str "%s%d" x i, v)) arr

  let rec pp_param (box : ('a, Format.formatter, unit) format) fmt
    ((x, ty) : string * param_type) =
    let rec pp_p fmt (x, ty) =
      match ty with
      | Any -> Fmt.pf fmt {|esl_symbolic.any("%s")|} x
      | Number -> Fmt.pf fmt {|esl_symbolic.number("%s")|} x
      | String -> Fmt.pf fmt {|esl_symbolic.string("%s")|} x
      | Boolean -> Fmt.pf fmt {|esl_symbolic.boolean("%s")|} x
      | Function -> Fmt.pf fmt {|esl_symbolic.function("%s")|} x
      | Object `Lazy -> Fmt.pf fmt "esl_symbolic.lazy_object()"
      | Object (`Polluted n) -> Fmt.pf fmt "esl_symbolic.polluted_object(%d)" n
      | Object (`Normal props) -> Fmt.pf fmt "@[{ %a@ }@]" pp_obj_props props
      | Array arr ->
        Fmt.pf fmt "@[<hov 2>[ %a ]@]"
          (Fmt.iter ~sep:Fmt.comma (array_iter x) pp_p)
          arr
      | Union _ -> assert false
    in
    Fmt.pf fmt box x pp_p (x, ty)

  and pp_obj_props fmt props =
    Fmt.list
      ~sep:(fun fmt () -> Fmt.pf fmt "@\n, ")
      (pp_param "@[<hov 2>%s:@ %a@]")
      fmt props

  and pp_params_as_decl fmt (params : (string * param_type) list) =
    Fmt.list
      ~sep:(fun fmt () -> Fmt.pf fmt ";@\n")
      (pp_param "@[<hov 2>var %s =@ %a@]")
      fmt params

  let pp_params_as_args fmt (args : (string * 'a) list) =
    let args = List.map fst args in
    let sep fmt () = Fmt.pf fmt ", " in
    Fmt.list ~sep Fmt.string fmt args

  let normalize =
    String.map (fun c ->
      match c with
      | '.' | ' ' -> '_'
      | _ -> c )

  let rec pp fmt { source; params; cont; _ } =
    let open Option in
    if List.length params > 0 then Fmt.pf fmt "%a;@\n" pp_params_as_decl params;
    match (cont, source) with
    | None, Some "" -> ()
    | None, Some source -> Fmt.pf fmt "%s(%a);" source pp_params_as_args params
    | Some (Return ret), Some source ->
      let var_aux = Fmt.str "ret_%s" (normalize source) in
      Fmt.pf fmt "var %s = %s(%a);@\n" var_aux source pp_params_as_args params;
      let source =
        let* ret_source = ret.source in
        Some (String.cat var_aux ret_source)
      in
      pp fmt { ret with source }
    | Some (Sequence cont), Some source ->
      Fmt.pf fmt "%s(%a);@\n" source pp_params_as_args params;
      pp fmt cont
    | (Some (Return _ | Sequence _ | Client _) | None), _ -> assert false

  let to_string v = Fmt.str "%a" pp v

  let render ({ Scheme.ty; _ } as summary) =
    let template = dispatch ty in
    let models =
      [ ("vuln_ty", Fmt.str "%a" (Fmt.option Vuln_type.pp) ty)
      ; ("test", to_string summary)
      ]
    in
    Template.render template models
end
