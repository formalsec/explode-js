open Smtml.Syntax.Result

type options =
  { debug : bool
  ; filename : Fpath.t
  ; workspace : Fpath.t
  ; time_limit : float
  }

let options debug filename workspace time_limit =
  { debug; filename; workspace; time_limit }

let run_with_timeout limit f =
  let exception Sigchld in
  let open Unix in
  let did_timeout = ref false in
  let pid = fork () in
  if pid = 0 then begin
    exit (f ())
  end
  else begin
    ( try
        Sys.set_signal Sys.sigchld (Signal_handle (fun _ -> raise Sigchld));
        Unix.sleepf limit;
        did_timeout := true;
        Unix.kill pid Sys.sigkill;
        Sys.set_signal Sys.sigchld Signal_default
      with Sigchld -> () );
    let chldpid, status = waitpid [] pid in
    assert (chldpid = pid);
    if !did_timeout then `Timeout
    else
      match status with
      | WEXITED n -> `Ok n
      | WSIGNALED _ | WSTOPPED _ -> `Timeout
  end

let run ({ debug; filename = test; workspace; time_limit } : options) =
  let* _ = Bos.OS.Dir.create workspace in
  let workspace = Fpath.(workspace // rem_ext (base test)) in
  let work () =
    let n =
      Cmd_symbolic.main
        { debug; filename = test; entry_func = "main"; workspace }
        ()
    in
    if n <> 0 then n else Cmd_replay.main { filename = test; workspace } ()
  in
  let result =
    if time_limit > 0. then run_with_timeout time_limit work else `Ok (work ())
  in
  Ok
    ( match result with
    | `Ok n -> n
    | `Timeout ->
      Format.printf "Reached time_limit@.";
      1 )

let main opts =
  match run opts with
  | Ok n -> n
  | Error (`Msg msg) ->
    Format.eprintf "error: %s@." msg;
    Cmdliner.Cmd.Exit.some_error
